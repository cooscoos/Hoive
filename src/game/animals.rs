// The logic that defines allowed moves for animals in the game

use std::collections::{HashMap, HashSet};

use crate::game::board::*;
use crate::maths::{coord::Coord, morphops};

pub fn ant_check<T: Coord>(
    board: &Board<T>,
    source: &(i8, i8, i8),
    dest: &(i8, i8, i8),
) -> MoveStatus {
    // Get positions of hexes that are inaccessible to ants, bees and spiders
    // Do this by morphological closing of a binary image of the board: i.e. dilation followed by erosion
    // Any new hexes generated by closing will be at locations that ants, bees, spiders can't access.

    // Get the positions of chips on the board
    let mut chip_positions = board.get_placed_positions();

    // Remove the chip at our "source" from our flat vector, we don't want it to be part of our dilation
    chip_positions.retain(|&p| p != *source);

    // Get hexes that this ant/bee/spider can't access
    let forbidden_hexes = morphops::gap_closure(&board.coord, &chip_positions);

    // Are any of those hexes equal to the desired destination?
    match forbidden_hexes.iter().any(|t| t == dest) {
        true => MoveStatus::SmallGap,
        false => MoveStatus::Success,
    }
}

pub fn bee_check<T: Coord>(
    board: &Board<T>,
    source: &(i8, i8, i8),
    dest: &(i8, i8, i8),
) -> MoveStatus {
    // Do an ant_check plus make sure dest is a neighbour of source (bee moves 1)
    match ant_check(&board, source, dest) {
        MoveStatus::SmallGap => MoveStatus::SmallGap,
        MoveStatus::Success => {
            // Check if the distance is within the bee's travel range (its neighbours)
            let neighbours = board.coord.neighbour_tiles(*source);
            match neighbours.contains(dest) {
                true => MoveStatus::Success,
                false => MoveStatus::TooFar(1),
            }
        }
        _ => unreachable!(), // this chip can't return other movestatus types
    }
}

pub fn spider_check<T: Coord>(
    board: &Board<T>,
    source: &(i8, i8, i8),
    dest: &(i8, i8, i8),
) -> MoveStatus {
    // Do an ant check and then check the spider is moving <=3 places (around obstacles)
    match ant_check(&board, source, dest) {
        MoveStatus::SmallGap => MoveStatus::SmallGap,
        MoveStatus::Success => {
            // Get list of hexes spider can visit within 3 moves (including around obstacles)
            let visitable = dist_lim_floodfill(&board, source, 3);
            match visitable.contains(dest) {
                true => MoveStatus::Success,
                false => MoveStatus::TooFar(3),
            }
        }
        _ => unreachable!(), // this chip can't return other movestatus types
    }
}

pub fn dist_lim_floodfill<T: Coord>(
    board: &Board<T>,
    source: &(i8, i8, i8),
    stam: u8,
) -> HashSet<(i8, i8, i8)> {
    // Distance-limited flood fill can find movement ranges around obstacles
    // See: https://www.redblobgames.com/grids/hexagons/#distances
    // Returns all hexes that this chip could visit, given its movement range (stam)

    // Store visitable hexes here
    let mut visitable = HashSet::new();

    // And add our current starting position
    visitable.insert(*source);

    // Store fringes: a list of all hexes that can be reached within k steps
    let mut fringes = HashMap::new();

    // Add the current position to fringes. It can be reached in k = 0 steps.
    fringes.insert(*source, 0);

    // Also need the position of existing chips on the board
    let obstacles = board.get_placed_positions();

    for k in 1..=stam {
        // Get the list of hexes within fringes that have values of k-1
        let check_hexes = fringes
            .iter()
            .filter(|(p, v)| **v == k - 1)
            .map(|(p, v)| *p)
            .collect::<Vec<(i8, i8, i8)>>();

        // For each of those hexes
        for check_hex in check_hexes {
            // Get the 6 neighbours
            let neighbours = board.coord.neighbour_tiles(check_hex);

            // These neighbours are visitable if they aren't blocked by an obstacle (and for efficiency, aren't already listed as visitable)
            neighbours.iter().for_each(|n| {
                if !obstacles.contains(n) & !visitable.contains(n) {
                    visitable.insert(*n);
                    fringes.insert(*n, k);
                }
            });
        }
    }
    visitable
}
