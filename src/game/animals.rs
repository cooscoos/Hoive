/// This module contains the additional rules that constrain animal movement
use std::collections::{HashMap, HashSet};

use crate::game::{board::Board, movestatus::MoveStatus};
use crate::maths::{coord::Coord, morphops};

/// Check whether the ant can move from source to dest.
/// If there is a small gap between source and dest then this will return
/// MoveStatus::SmallGap.
///
/// This function is also used by bees, spiders and pillbugs.
pub fn ant_check<T: Coord>(board: &Board<T>, source: &T, dest: &T) -> MoveStatus {
    // Get current chip positions
    let mut chip_positions = board.get_placed_positions();

    // Remove the chip at "source", we don't want it to be part of the closure
    chip_positions.retain(|&p| p != *source);

    // Find forbidden hexes that the ant can't access
    // Do this by morphological closing (dilation followed by erosion).
    // Any new hexes generated by this operation will be at locations that ants, bees, spiders can't access.
    let forbidden_hexes = morphops::gap_closure(&board.coord, &chip_positions);

    // Are any forbidden hexes the same as desire destination?
    match forbidden_hexes.contains(dest) {
        true => MoveStatus::SmallGap,
        false => MoveStatus::Success,
    }
}

/// Check whether bee can move from source to dest.
/// This involves an ant check, plus ensuring that the chip is only moving one hex.
///
/// This function is also used by pillbugs.
pub fn bee_check<T: Coord>(board: &Board<T>, source: &T, dest: &T) -> MoveStatus {
    // Do an ant check first
    match ant_check(board, source, dest) {
        MoveStatus::SmallGap => MoveStatus::SmallGap,
        MoveStatus::Success => {
            // Check if the distance is within the bee's travel range (its immediate neighbours)
            let neighbours = board.coord.neighbour_tiles(*source);
            match neighbours.contains(dest) {
                true => MoveStatus::Success,
                false => MoveStatus::BadDistance(1),
            }
        }
        _ => unreachable!(), // this chip can't return other movestatus types
    }
}

/// Check whether spider can move from source to dest.
/// This involves an ant check, plus ensuring that the source and dest are
/// 3 hexes apart (moving around obstacles if necessary).
pub fn spider_check<T: Coord>(board: &Board<T>, source: &T, dest: &T) -> MoveStatus {
    // Do an ant check first
    match ant_check(board, source, dest) {
        MoveStatus::SmallGap => MoveStatus::SmallGap,
        MoveStatus::Success => {
            // Get list of hexes spider can visit within 3 moves (including around obstacles).
            // Achieve this using a distance limited floodfill.
            // The move rules define whether spider should travel over occupied spaces (it never should)
            let move_rules = vec![false, false, false];
            let visitable = mod_dist_lim_floodfill(board, source, move_rules);

            // If the destination is visitable on turn 3, the move is good.
            match visitable.contains(dest) {
                true => MoveStatus::Success,
                false => MoveStatus::BadDistance(3),
            }
        }
        _ => unreachable!(), // this chip can't return other movestatus types
    }
}

/// Check whether ladybird can move from source to dest.
/// This involes an ant check, plus ensuring source and dest are 3
/// hexes apart (travelling over other hexes).
pub fn ladybird_check<T: Coord>(board: &Board<T>, source: &T, dest: &T) -> MoveStatus {
    // Don't do an ant check first -- I think ladybird should skip this.

    // Get list of hexes ladybird can visit within 3 moves
    // The move rules define whether ladybird should travel over occupied spaces
    // (it must on its first two movements, but shouldn't on its last).
    let move_rules = vec![true, true, false];
    let visitable = mod_dist_lim_floodfill(board, source, move_rules);

    // If destination is visitable on turn 3, the move is good.
    match visitable.contains(dest) {
        true => MoveStatus::Success,
        false => MoveStatus::BadDistance(3),
    }
}

/// Check whether beetle can move from source to dest. 
/// If there is a small gap between source and dest then this will return
/// MoveStatus::SmallGap.
/// 
/// This is different to the ant_check because ant_check closes off all hexes
/// beyond a small gap. The same isn't needed for beetles because they can move
/// over other chips into areas that an ant can't access. As a result, the
/// beetle check is a lot less clever and much more manual.
pub fn beetle_check<T: Coord>(board: &Board<T>, source: &T, dest: &T) -> MoveStatus {

    let placed_hexes = board.get_placed_positions();

    // Get the positions of chips neighbouring source
    let source_neighbour_hexes = board.coord.neighbour_tiles(*source);
    let source_neighbours = placed_hexes.intersection(&source_neighbour_hexes).collect::<HashSet<&T>>();

    // Get the positions of chips neighbouring dest
    let dest_neighbour_hexes = board.coord.neighbour_tiles(*dest);
    let dest_neighbours = placed_hexes.intersection(&dest_neighbour_hexes).collect::<HashSet<&T>>();

    // The common neighbours between source and dest will be the ones that are in the way of the desired move from source to dest
    // If there are 2 of them, then it means we have a small gap and the move can't be allowed
    match source_neighbours.intersection(&dest_neighbours).count() == 2 {
        true => MoveStatus::SmallGap,
        false => MoveStatus::Success,
    }

}

/// A modified distance-limited flood fill which can find movement ranges around and over obstacles.
/// Useful for spiders and ladybirds.
/// See: https://www.redblobgames.com/grids/hexagons/#distances
///
/// Returns all hexes that this chip could visit on its final turn
/// Each element of the move_rules vector can be:
/// false: must move to a non-occupied position on this move (e.g. all spider turns, ladybird turn 3)
/// true: must move to an occupied position on this move (e.g. ladybird turns 1 and 2)
pub fn mod_dist_lim_floodfill<T: Coord>(
    board: &Board<T>,
    source: &T,
    move_rules: Vec<bool>,
) -> HashSet<T> {
    // Store visitable hexes in this hashset
    let mut visitable = HashSet::new();

    // Store fringes: a list of all hexes that can be reached within k steps
    let mut fringes = HashMap::new();

    // Add the current position to fringes. It can be reached in k = 0 steps.
    fringes.insert(*source, 0);

    // Also need the position of existing chips on the board
    let obstacles = board.get_placed_positions();

    for k in 1..=move_rules.len() {
        // Get the list of hexes within fringes that have values of k-1
        let check_hexes = fringes
            .iter()
            .filter(|(_, v)| **v == k - 1)
            .map(|(p, _)| *p)
            .collect::<Vec<T>>();

        // For each of those hexes
        for check_hex in check_hexes {
            // Get the 6 neighbours
            let neighbours = board.coord.neighbour_tiles(check_hex);

            neighbours.iter().for_each(|n| {
                // These neighbours are visitable on this turn (k) if ...
                let can_visit = match move_rules[k - 1] {
                    // (match on k-1 because of how vectors are indexed)
                    true => obstacles.contains(n), // they are blocked by an obstacle
                    false => !obstacles.contains(n), // they are not blocked by an obstacle
                };

                if can_visit & !visitable.contains(n) {
                    // don't keep overwriting values in hashset (inefficient)
                    fringes.insert(*n, k); // add the neighbour to the list of fringes for this k

                    // We only care about what hexes this peice can visit on its final turn
                    if k == move_rules.len() {
                        visitable.insert(*n);
                    }
                }
            });
        }
    }
    visitable
}

/// Adjusts the beetle destination so that the beetle can climb into higher or lower layers
pub fn layer_adjust<T: Coord>(board: &Board<T>, mut dest: T) -> T {
    // If there's nothing in the way, decrease layer number by one and repeat until there's a free layer
    // or until we hit layer 0
    while board.get_chip(dest).is_some() == false && dest.get_layer() != 0 {
        dest.descend();
    }

    // If there's something in the way, increase layer number by one and repeat until there's a free layer
    while board.get_chip(dest).is_some() == true {
        dest.ascend();
    }

    dest
}
