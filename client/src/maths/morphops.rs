use super::coord::Coord;
/// A module of morphological operations such as dilation, erosion, closing.
use std::collections::HashSet;

/// Dilation of a binary image of a hex board (in a 3 component co-ordinate system)
/// Dilation is performed with a window size that encompasses immediate neighbours.
pub fn dilate<T: Coord>(coord: &T, binary_img: &HashSet<T>) -> HashSet<T> {
    // Hashset for keeping track of chip locations
    let mut store: HashSet<T> = HashSet::new();

    // Add all of the current hexes to the hashset
    binary_img.iter().for_each(|v| {
        store.insert(*v);
    });

    // Perform the dilation
    for position in binary_img {
        // Get the co-ordinates of neighbouring hexes and add them to the hashset (this is equivalent to dilation with window size 1)
        let neighbour_hexes = coord.neighbours_layer0(*position);
        neighbour_hexes.iter().for_each(|v| {
            store.insert(*v);
        });
    }
    store.into_iter().collect::<HashSet<T>>()
}

/// Erosion of a binary image of a hex board (in a 3 component co-ordinate system)
/// Erosion is performed with a window size that encompasses immediate neighbours.
pub fn erode<T: Coord>(coord: &T, binary_img: &HashSet<T>) -> HashSet<T> {
    //Hashset for keeping track of chip locations
    let mut store: HashSet<T> = HashSet::new();

    // Add all of the current hexes to the hashset
    binary_img.iter().for_each(|v| {
        store.insert(*v);
    });

    for position in binary_img {
        // Get the co-ordinates of neighbouring hexes
        let neighbour_hexes = coord.neighbours_layer0(*position);

        // If a hex doesn't have all six neighbours, then it gets removed from the hashset (erosion)
        let neighbours = neighbour_hexes.intersection(binary_img).count();

        if neighbours != 6 {
            store.remove(position);
        }
    }
    store
}

/// Morphological closing of a binary hex board (dilation followed by erosion)
pub fn close<T: Coord>(coord: &T, binary_img: &HashSet<T>) -> HashSet<T> {
    let dilated = dilate(coord, binary_img);
    erode(coord, &dilated)
}

/// Perform morphological closing but only return the new hexes which were generated by the
/// closing operation.
pub fn close_new<T: Coord>(coord: &T, binary_img: &HashSet<T>) -> HashSet<T> {
    // Do the closure
    let closed = close(coord, binary_img);

    let mut store = HashSet::new();
    // Add all of the closed hexes to the hashset
    closed.iter().for_each(|v| {
        store.insert(*v);
    });

    // Delete all of the originals to see what's new
    binary_img.iter().for_each(|v| {
        store.remove(v);
    });

    store
}
/// This function is used to find out where small gaps are on a board. We pass the function a binary image
/// of the board (a hashset only containing the positions of chips).
///
/// The function performs a morphological closure on this binary image, seeing what new hexes are generated.
/// It then considers these new hexes, and lightly erodes them, retaining only hexes which have 5 or 6 neighbours.
///
/// The result of this operation, and the function's return value, is a collection of
/// hexes which cannot be accessed by e.g. ants, because the gaps are too small for the ant to pass.
pub fn gap_closure<T: Coord>(coord: &T, binary_img: &HashSet<T>) -> HashSet<T> {
    // Will store the return values here
    let mut store = HashSet::new();

    // First find new tiles from morpholical closing
    let ghosts = close_new(coord, binary_img);

    // Add all of the closed hexes to the store hashset
    ghosts.iter().for_each(|v| {
        store.insert(*v);
    });

    // create a new hashset of all tiles, ghost and real
    let mut all = HashSet::new();
    ghosts.iter().for_each(|v| {
        all.insert(*v);
    });
    binary_img.iter().for_each(|v| {
        all.insert(*v);
    });

    // For each ghost hex
    for position in ghosts {
        // Count the neighbouring hexes that have chips in them
        let neighbour_hexes = coord.neighbours_layer0(position);
        let neighbours = neighbour_hexes.intersection(&all).count();

        // If this hex doesn't have five or all of its neighbours, then it gets removed from the hashset
        // This is like an addtional light erosion.
        if neighbours < 5 {
            store.remove(&position);
        }
    }
    store
}
