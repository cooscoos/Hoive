/// This module contains the additional rules that constrain animal movement
use std::collections::{HashMap, HashSet};

use crate::game::{board::Board, movestatus::MoveStatus};
use crate::maths::{coord::Coord, morphops};

/// Check whether the ant can move from source to dest.
/// If there is a small gap between source and dest then this will return
/// MoveStatus::SmallGap.
///
/// This function can also used by e.g. bees, spiders and pillbugs,
/// but it's more efficient to use a beetle_check for those.
pub fn ant_check<T: Coord>(board: &Board<T>, source: &T, dest: &T) -> MoveStatus {
    // Get current chip positions
    let mut chip_positions = board.get_placed_positions();

    // Remove the chip at "source", we don't want it to be part of the closure
    chip_positions.retain(|&p| p != *source);

    // Find forbidden hexes that the ant can't access
    // Do this by morphological closing (dilation followed by erosion).
    // Any new hexes generated by this operation will be at locations that ants, bees, spiders can't access.
    let forbidden_hexes = morphops::gap_closure(&board.coord, &chip_positions);

    // Are any forbidden hexes the same as desire destination?
    match forbidden_hexes.contains(dest) {
        true => MoveStatus::SmallGap,
        false => MoveStatus::Success,
    }
}

/// Check whether bee can move from source to dest.
/// This involves a small gap check, plus ensuring that the chip is only moving one hex.
///
/// This function is also used by pillbugs and beetles.
pub fn bee_check<T: Coord>(board: &Board<T>, source: &T, dest: &T) -> MoveStatus {
    // Do a basic check first for small gaps
    match basic_gap_check(board, source, dest) {
        MoveStatus::SmallGap => MoveStatus::SmallGap,
        MoveStatus::Success => {
            // Check if the distance is within the bee's travel range (its immediate neighbours)
            // Using dest.to_bottom ignores the layer information of dest and allows beetles to use this function
            let neighbours = board.coord.neighbours_layer0(*source);
            match neighbours.contains(&dest.to_bottom()) {
                true => MoveStatus::Success,
                false => MoveStatus::BadDistance(1),
            }
        }
        _ => unreachable!(), // this chip can't return other movestatus types
    }
}

/// Check whether spider can move from source to dest.
/// This involves an ant check, plus ensuring that the source and dest are
/// 3 hexes apart (moving around obstacles if necessary).
pub fn spider_check<T: Coord>(board: &Board<T>, source: &T, dest: &T) -> MoveStatus {
    // Do an ant check first
    match ant_check(board, source, dest) {
        MoveStatus::SmallGap => MoveStatus::SmallGap,
        MoveStatus::Success => {
            // Get list of hexes spider can visit within 3 moves (including around obstacles).
            // Achieve this using a distance limited floodfill.
            // The move rules define whether spider should travel over occupied spaces (it never should)
            let move_rules = vec![false, false, false];
            let visitable = mod_dist_lim_floodfill(board, source, move_rules);

            // If the destination is visitable on turn 3, the move is good.
            match visitable.contains(dest) {
                true => MoveStatus::Success,
                false => MoveStatus::BadDistance(3),
            }
        }
        _ => unreachable!(), // this chip can't return other movestatus types
    }
}

/// Check whether ladybird can move from source to dest.
/// This involes an ant check, plus ensuring source and dest are 3
/// hexes apart (travelling over other hexes).
pub fn ladybird_check<T: Coord>(board: &Board<T>, source: &T, dest: &T) -> MoveStatus {
    // Don't do an ant check first -- I think ladybird should skip this.

    // Get list of hexes ladybird can visit within 3 moves
    // The move rules define whether ladybird should travel over occupied spaces
    // (it must on its first two movements, but shouldn't on its last).
    let move_rules = vec![true, true, false];
    let visitable = mod_dist_lim_floodfill(board, source, move_rules);

    // If destination is visitable on turn 3, the move is good.
    match visitable.contains(dest) {
        true => MoveStatus::Success,
        false => MoveStatus::BadDistance(3),
    }
}


/// Check whether chip can move from source to dest.
/// If there is a small gap between source and dest then this will return
/// MoveStatus::SmallGap. This check will work on any chip that only moves one
/// space (bees, pillbugs, beetles), and will be more efficient than an ant_check.
pub fn basic_gap_check<T: Coord>(board: &Board<T>, source: &T, dest: &T) -> MoveStatus {
    let placed_hexes = board.get_placed_positions();

    // Get the positions of chips neighbouring source, but only on the beetle's current later (this could be tidied up with a new trait method to get neighbours on current layer)
    let source_neighbour_hexes = board.coord.neighbours_onlayer(*source, source.get_layer());

    let source_neighbours = placed_hexes
        .intersection(&source_neighbour_hexes)
        .collect::<HashSet<&T>>();

    // Get the positions of chips neighbouring dest
    let dest_neighbour_hexes = board.coord.neighbours_onlayer(*dest, dest.get_layer());

    let dest_neighbours = placed_hexes
        .intersection(&dest_neighbour_hexes)
        .collect::<HashSet<&T>>();

    // The common neighbours between source and dest will be the ones that are in the way of the desired move from source to dest
    // If there are 2 of them, then it means we have a small gap and the move can't be allowed
    match source_neighbours.intersection(&dest_neighbours).count() == 2 {
        true => MoveStatus::SmallGap,
        false => MoveStatus::Success,
    }
}

/// Check whether grasshopper can move from source to dest
pub fn ghopper_check<T: Coord>(board: &Board<T>, source: &T, dest: &T) -> MoveStatus {
    // A grasshopper can move in a straght line in one of 6 directions --- we'll call them the cardinal directions.
    // The cardinal directions have the same unit vectors as the coordinates of the 6 neighbours of the origin
    let allowed_dirs = board.coord.neighbours_layer0(T::new(0, 0, 0));

    // Get the unit vector of the grasshopper's proposed travel direction and make sure it's moving in an allowed direction.
    let travel_dir = board.coord.get_unitvec(*source, *dest);

    if !allowed_dirs.contains(&travel_dir) {
        return MoveStatus::NoJump;
    }

    // Start one step away from the grasshopper's location.
    let mut current_pos = *source + travel_dir;

    // If we're already at the destination hex, then we've tried to move to an immediate empty neighbour
    // without hopping over occupied hexes. Grasshoppr can't do this.
    if current_pos == *dest {
        return MoveStatus::NoJump;
    }

    // Now, keep travelling one step at a time until we reach dest, making sure all hexes on the way are occupied
    while current_pos < *dest {
        // If we're ever leaping over an unoccupied hex, then we can't do this jump.
        if board.get_chip(current_pos) == None {
            return MoveStatus::NoJump;
        }

        // Add a step
        current_pos = current_pos + travel_dir;
    }

    // If we passed all of these tests, the jump was okay
    MoveStatus::Success
}

/// A modified distance-limited flood fill which can find movement ranges around and over obstacles.
/// Useful for spiders and ladybirds.
/// See: https://www.redblobgames.com/grids/hexagons/#distances
///
/// Returns all hexes that this chip could visit on its final turn
/// Each element of the move_rules vector can be:
/// false: must move to a non-occupied position on this move (e.g. all spider turns, ladybird turn 3)
/// true: must move to an occupied position on this move (e.g. ladybird turns 1 and 2)
pub fn mod_dist_lim_floodfill<T: Coord>(
    board: &Board<T>,
    source: &T,
    move_rules: Vec<bool>,
) -> HashSet<T> {
    // Store visitable hexes in this hashset
    let mut visitable = HashSet::new();

    // Store fringes: a list of all hexes that can be reached within k steps
    let mut fringes = HashMap::new();

    // Add the current position to fringes. It can be reached in k = 0 steps.
    fringes.insert(*source, 0);

    // Also need the position of existing chips on the board
    let obstacles = board.get_placed_positions();

    for k in 1..=move_rules.len() {
        // Get the list of hexes within fringes that have values of k-1
        let check_hexes = fringes
            .iter()
            .filter(|(_, v)| **v == k - 1)
            .map(|(p, _)| *p)
            .collect::<Vec<T>>();

        // For each of those hexes
        for check_hex in check_hexes {
            // Get the 6 neighbours
            let neighbours = board.coord.neighbours_layer0(check_hex);

            neighbours.iter().for_each(|n| {
                // These neighbours are visitable on this turn (k) if ...
                let can_visit = match move_rules[k - 1] {
                    // (match on k-1 because of how vectors are indexed)
                    true => obstacles.contains(n), // they are blocked by an obstacle
                    false => !obstacles.contains(n), // they are not blocked by an obstacle
                };

                if can_visit & !visitable.contains(n) {
                    // don't keep overwriting values in hashset (inefficient)
                    fringes.insert(*n, k); // add the neighbour to the list of fringes for this k

                    // We only care about what hexes this peice can visit on its final turn
                    if k == move_rules.len() {
                        visitable.insert(*n);
                    }
                }
            });
        }
    }
    visitable
}

/// Adjusts the beetle destination so that the beetle can climb into higher or lower layers
pub fn layer_adjust<T: Coord>(board: &Board<T>, mut dest: T) -> T {
    // If there's nothing in the way, decrease layer number by one and repeat until there's a free layer
    // or until we hit layer 0
    while board.get_chip(dest).is_none() && dest.get_layer() != 0 {
        dest.descend();
    }

    // If there's something in the way, increase layer number by one and repeat until there's a free layer
    while board.get_chip(dest).is_some() {
        dest.ascend();
    }

    dest
}
